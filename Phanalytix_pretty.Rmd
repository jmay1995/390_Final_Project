---
title: "Phanalytix"
author: "Joseph May, Rachel Nesbit, Aishwarya Harihan"
date: "April 5, 2017"
output: html_document
---
#stor390Project

#Whats left
-parsing show time
-song gap
-rotation
*take songs from phish.net to avoid segue problem?

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
#setup
library(rvest)
library(jsonlite)
library(tidyverse)
library(stringr)
```

```{r Phish.in years API}
#Save the base URL for the API 
url_phishin <- 'http://phish.in/api/v1'

#concatenate '/years' to the end of the API for the call to a list of years
url_years <- str_c(url_phishin, '/years')

#read in a raw JSON file for a list of years
json_years <- read_lines(url_years)

#returns a list of every year phish played shows
years <- fromJSON(json_years)$data
```

```{r Phish.in shows API}
#using a for loop, create a tibble that takes the list of years, and runs each entry back through the API to return a list of every show that was played that year, then do a full join each time to compile a list of every show
for(i in 1:length(years)){
  
    url_year_i <- str_c(url_phishin, '/years/', years[i])
    
    json_year_i <- read_lines(url_year_i)
    
    year_i <- fromJSON(json_year_i)

    #for the 1st show we name the tibble differently so that we have an initial tibble to join with the     other show tibbles
    if(i == 1){
        shows <- as_tibble(year_i$data)
    } else{
        year_tibble <- as_tibble(year_i$data)
        
        #a full join with all categories, so we're essentially just compiling tibbles
        shows <- full_join(year_tibble, shows, by = c("id", 
                                                      "date", 
                                                      "duration", 
                                                      "incomplete", 
                                                      "missing", 
                                                      "sbd", 
                                                      "remastered", 
                                                      "tour_id",
                                                      "venue_id", 
                                                      "likes_count", 
                                                      "taper_notes", 
                                                      "updated_at", 
                                                      "venue_name", 
                                                      "location"))
    }
 }

#Parse date as datetime and remove unnecessary variables 
shows <- shows %>% 
    select(-taper_notes, -updated_at, -incomplete, -missing, -sbd, -remastered) %>% 
    mutate(date = parse_datetime(date)) %>% 
    arrange(desc(date))

#save the data set, so that we don't have to run the API code over & over again
write_csv(shows, 'shows.csv')

#manually read in the data to make the computation run faster.
shows <- read_csv('shows.csv')

```

```{r Phish.net ratings API}
#the API key for application "jmay1995" is: E972636BCF5D4EF75256
API_key <- 'E972636BCF5D4EF75256'
#the Public key for application "jmay1995" is: 4A474082F30E6491601A
public_key <- '4A474082F30E6491601A'

#save the setlist URL for the API
url_phishnet_setlists <- 'https://api.phish.net/v3/setlists/get?apikey='

#save the end URL for the API
url_phishnet_end <- '&showdate='

#create a (currently blank) column for ratings in the shows tibble 
ratings <- vector(mode="character", length=dim(shows)[1])
shows <- add_column(shows, ratings = ratings)

#this show does not exist, it was spread around with a false date but it actually occured on 4/25/86; some of the sources of our song and show data include the false show but with blanks for all the data, so we have removed it
shows <- filter(shows, id != 9) 

#for each showdate, we read in the setlist as a raw JSON from the API, convert to a list, then add the entry of the ratings list to each entry of our shows tibble
for(i in 1:dim(shows)[1]){
    showdate <- as.character.Date(shows$date[i])
    
    url_full <- str_c(url_phishnet_setlists, API_key, url_phishnet_end, showdate)
    
    json_setlist <- read_lines(url_full)
    
    setlist <- fromJSON(json_setlist)
    
    shows$ratings[i] <- setlist$response$data$rating
}

```

```{r Phish.in tours API}
#Use the shows tibble & group_by to create a tibble with all of the tour IDs used by phish.in
tour_ids <- shows %>% 
    group_by(tour_id) %>% 
    summarise()

#Save the base URL for the API 
url_phishin <- 'http://phish.in/api/v1'

#create initial tibble with first tour, pulling data in raw JSON format and putting it into a tibble
url_tour <- str_c(url_phishin, '/tours/', tour_ids[1,])
json_tour <- read_lines(url_tour)
tour <- (fromJSON(json_tour))
tours <- tibble(tour_id = tour$data$id, 
                name = tour$data$name, 
                tour = tour$data$slug)

#loop over the remaining tours, adding the new tour names to the original "tours" tibble using joins
for(i in 2:dim(tour_ids)[1]) {
    url_tour <- str_c(url_phishin, '/tours/', tour_ids[i,])
    json_tour <- read_lines(url_tour)
    tour <- (fromJSON(json_tour))
    
    tours_loop <- tibble(tour_id = tour$data$id, 
                name = tour$data$name, 
                tour = tour$data$slug)
    
    tours <- full_join(tours, tours_loop, by = c("tour_id", 
                                                 "name", 
                                                 "tour"))
}

#add the tour information for each show to our "shows" tibble
shows <- left_join(shows, tours, by = "tour_id")

#remove the venue id column because it is not necessary
shows <- shows %>% 
    select(-venue_id)

```

```{r Phish.in tracks API}
#create a tibble "tracks" which contains each song in each show by adding the show date from the shows tibble into the 'show-on-date' API, converting to text, adding in the corresponding date, and changing song ID from a list type for later joins

#first create an initial tibble for the first show's songs
url_pishin_show <- str_c(url_phishin, '/show-on-date/:', shows$date[1])
json_show <- read_lines(url_pishin_show)
json_tracks <- fromJSON(json_show)
tracks <- json_tracks$data$tracks %>% 
                as_tibble() %>% 
                select(-song_ids, 
                       -mp3, 
                       -updated_at) %>%  #don't need these variables 
                mutate(date = parse_datetime(shows$date[1])) #want the date to be parsed as date-time

#do the same for the rest of the shows, looping to create a tibble for each show's songs and then join it with the original tibble
for(i in 2:dim(shows)[1]){
    url_pishin_show <- str_c(url_phishin, '/show-on-date/:', shows$date[i])
    json_show <- read_lines(url_pishin_show)
    json_tracks <- fromJSON(json_show)
    
    tracks_loop <- json_tracks$data$tracks %>% 
                as_tibble() %>% 
                select(-song_ids, 
                       -mp3, 
                       -updated_at) %>% #don't need these variables
                mutate(date = parse_datetime(shows$date[i])) #want the date to be parsed as date-time

    #a full join with all categories to compile all the tracks
    tracks <- full_join(tracks_loop, tracks, 
                             by = c("id", 
                                    "title",
                                    "position",
                                    "duration",
                                    "set",
                                    "set_name",
                                    "likes_count",
                                    "slug",
                                    "date"))
} 

write_csv(tracks, 'tracks.csv')
```

```{r combine track data with show data}
#create a tibble that combines the information about songs with the information about shows

#left join adds show information for every song
songs_shows <- left_join(tracks, shows, by = "date") 

#cleaning up the tibble by removing and renaming variables
songs_shows <- songs_shows %>% 
    select(-slug, 
           -tour) %>% #don't need the URL slugs
    rename(song = title, #song is a more clear name than title
           like_count_song = likes_count.x, #clarify that x refers to song
           like_count_show = likes_count.y, #clarify that y refers to show
           id_song = id.x, #clarify that x refers to song
           id_show = id.y, #clarify that y refers to show
           id_tour = tour_id, #all ids should have same naming format
           duration_song = duration.x, #clarify that x refers to song
           duration_show = duration.y, #clarify that y refers to show
           tour = name) #tour is a more clear name than name

#reorganize the columns of the tibble to group variables more intuitively
songs_shows <- songs_shows[,c(2, 8, 3, 5, 6, 14, 13, 16, 15, 4, 10, 7, 12, 1, 9, 11)]

#save the data and read it in
write_csv(songs_shows, 'songs_shows.csv')
songs_shows <- read_csv('songs_shows.csv')
```



```{r Phish.net song API}
#creating a tibble which contains information about all of the songs Phish has played

#saving and reading in the url
url_phishnet <- 'http://phish.net/song'
html_songs <- read_html(url_phishnet)

#grabbing all of the text from the song history page on Phish.net
song_info <- html_songs %>% 
    html_nodes('td') %>% 
    html_text

#converting text from vector to data frame
song_info <- as_data_frame(song_info)

#removing rows with "alias of other songs" and the two rows before each occurrence because these songs were not actually played by Phish in shows 
song_info <- song_info[-c(5455:5598), ]

#splitting the song history by each song 
categories <- 6 #number of categories
song_indices <- seq(dim(song_info)[1]) #creates sequence from 1 to the length of dataframe 
#split by dividing row number by number of categories to get one index per song
song_history <- split(song_info, ceiling(song_indices/categories))  

#transposing and organizing song_history into a tibble 
song_data <- lapply(song_history, t) %>% 
    lapply(data.frame) %>% 
    bind_rows

#renaming variables to helpful names
song_data <- rename(song_data, 
                   song = X1, 
                   artist = X2, 
                   total_times_played = X3, 
                   debut = X4, 
                   last = X5, 
                   gap = X6) 

#change data type for "debut" and "last" variables to date time and removing unnecessary variables
song_data <- song_data%>%
                mutate(debut = as.Date(debut), 
                   last = as.Date(last))%>%
                select(-gap, -last)

#save the data and read it in
write_csv(song_data, 'song_data.csv')
song_data <- read_csv('song_data.csv')
```

```{r combine for final dataset}

#join together the information about the songs with the information about which songs were played at which shows
phanalytix <- left_join(songs_shows, song_data, by = "song")

#saving the dataset and reading it in
write_csv(phanalytix, 'phanalytix.csv')
phanalytix <- read_csv('phanalytix.csv')

```

```{r parse duration}
#to parse "duration" as a time

#write a function which converts the song time durations into minutes and seconds
song_parser <- function(x) {
    #formula to change original duration value into minutes and seconds
    adj_time <- trunc(x/60000)+((x/60000 - trunc(x/60000))*.6) 
    #parse the time as a character
    char_time <- parse_character(adj_time)
    #remove the slashes "\\." and replace with a dash "-"
    formatted_time <- str_replace(char_time, '\\.', '-')
    #parse as a time
    parsed_time <- strptime(formatted_time, format = "%M-%S")
    #change to only include the minutes and seconds
    duration_time <- strftime(parsed_time, format="%M:%S")
    
    #return the parsed duration value
    return(duration_time)
}

#apply the function to every song duration in the songs_shows tibble
song_duration_list <- lapply(phanalytix$duration_song, song_parser) %>%
    lapply(data.frame) %>% 
    bind_rows

#replace the original duration column with the new minute-second values
phanalytix <- mutate(phanalytix, duration_song = song_duration_list$X..i..)

```